from pathlib import Path
path = Path('mon-projet/src/frontend/src/pages/FlowComposer.tsx')
text = path.read_text()
start_marker = 'const handleRunWorkflow'
end_marker = 'const handlePauseWorkflow'
start_idx = text.find(start_marker)
end_idx = text.find(end_marker)
if start_idx == -1 or end_idx == -1:
    raise SystemExit('markers not found for handleRunWorkflow replacement')
new_block = """  const handleRunWorkflow = async (workflow: StoredWorkflow) => {\n    if (!backendUrl) {\n      setSnackbar({ severity: 'error', message: 'Backend unavailable: no URL configured.' });\n      return;\n    }\n\n    const deviceIds = selectedDeviceIds.length > 0 ? selectedDeviceIds : readSelectedDeviceIds();\n    if (deviceIds.length === 0) {\n      setSnackbar({\n        severity: 'error',\n        message: 'Select one or more devices on the dashboard before running a workflow.',\n      });\n      return;\n    }\n\n    const workflowSummary =\n      workflow.modules.map((module) => module.name).filter(Boolean).join(' ? ') || workflow.name;\n    const repeatSettings = getRepeatSettingsForWorkflow(workflow.id);\n    const normalizedRepeatCount = Number.isFinite(repeatSettings.repeatCount)\n      ? Math.max(1, Math.trunc(repeatSettings.repeatCount))\n      : 1;\n    const durationUnit: DurationUnit = repeatSettings.durationUnit ?? 'minutes';\n    const durationSeconds = convertDurationToSeconds(repeatSettings.durationValue ?? 0, durationUnit);\n\n    let backendWorkflowId = workflowBackendMap[workflow.id];\n    if (!backendWorkflowId) {\n      backendWorkflowId = await ensureBackendWorkflow(workflow);\n    }\n\n    let preflightReport: WorkflowPreflightReport | null = null;\n    try {\n      preflightReport = await performPreflightCheck(workflow.id, deviceIds);\n      setPreflightReports((prev) => ({ ...prev, [workflow.id]: preflightReport }));\n      if (!preflightReport.success) {\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: 'Preflight detected issues. Resolve them before running.',\n        }));\n        setSnackbar({\n          severity: 'warning',\n          message: 'Preflight detected issues on one or more devices.',\n        });\n        return;\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Preflight check failed.';\n      setWorkflowRunStatus((prev) => ({ ...prev, [workflow.id]: `Preflight error: ${message}` }));\n      setSnackbar({ severity: 'error', message });\n      return;\n    }\n\n    if (workflowCancelControllers.current[workflow.id]) {\n      workflowCancelControllers.current[workflow.id].abort();\n      delete workflowCancelControllers.current[workflow.id];\n    }\n    const workflowController = new AbortController();\n    workflowCancelControllers.current[workflow.id] = workflowController;\n    setWorkflowCancelRequests((prev) => ({ ...prev, [workflow.id]: false }));\n\n    setRunningWorkflows((prev) => ({ ...prev, [workflow.id]: true }));\n    setWorkflowActiveModuleIndex((prev) => ({\n      ...prev,\n      [workflow.id]: workflow.modules.length > 0 ? 0 : null,\n    }));\n    setWorkflowCompletedModules((prev) => ({ ...prev, [workflow.id]: [] }));\n    setWorkflowRunStatus((prev) => ({\n      ...prev,\n      [workflow.id]: `Planning workflow (${workflowSummary}) for ${deviceIds.length} device${deviceIds.length === 1 ? '' : 's'}.`,\n    }));\n    setSnackbar({\n      severity: 'info',\n      message: `Workflow "${workflow.name}" started (${workflowSummary}).`,\n    });\n\n    const sessionStart = Date.now();\n    const durationWindowMs = durationSeconds * 1000;\n    let runCounter = 0;\n    let completedRuns = 0;\n    let cancelled = false;\n\n    const waitWhilePaused = async () => {\n      if (!workflowPauseRef.current[workflow.id]) {\n        return;\n      }\n      setWorkflowRunStatus((prev) => ({\n        ...prev,\n        [workflow.id]: `Workflow "${workflow.name}" paused. Click resume to continue.`,\n      }));\n      while (workflowPauseRef.current[workflow.id]) {\n        await sleep(500);\n      }\n      setWorkflowRunStatus((prev) => ({\n        ...prev,\n        [workflow.id]: `Resuming workflow "${workflow.name}".`,\n      }));\n    };\n\n    try {\n      while (true) {\n        await waitWhilePaused();\n        if (isWorkflowCancelled(workflow.id)) {\n          cancelled = true;\n          break;\n        }\n\n        runCounter += 1;\n        const runLabel = `Run #${runCounter}`;\n\n        setWorkflowCompletedModules((prev) => ({ ...prev, [workflow.id]: workflow.modules.map((_, idx) => idx) }));\n        setWorkflowActiveModuleIndex((prev) => ({\n          ...prev,\n          [workflow.id]: workflow.modules.length > 0 ? workflow.modules.length - 1 : null,\n        }));\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `Starting ${runLabel} (${workflowSummary}) on ${deviceIds.length} device${deviceIds.length === 1 ? '' : 's'}.`,\n        }));\n\n        const runResult = await executeBackendWorkflow(backendWorkflowId, deviceIds, workflowController.signal);\n        const report = buildExecutionReport(workflow, runResult, deviceIds);\n        setWorkflowExecutionReports((prev) => ({ ...prev, [workflow.id]: report }));\n\n        const deviceOutcomes: Record<string, { success: boolean; reasons: string[] }> = {};\n        deviceIds.forEach((deviceId) => {\n          deviceOutcomes[deviceId] = { success: true, reasons: [] };\n        });\n        report.results.forEach((step) => {\n          step.deviceResults.forEach((deviceResult) => {\n            if (!deviceResult.success && deviceOutcomes[deviceResult.deviceId]) {\n              deviceOutcomes[deviceResult.deviceId].success = false;\n              if (deviceResult.message) {\n                deviceOutcomes[deviceResult.deviceId].reasons.push(deviceResult.message);\n              }\n            }\n          });\n        });\n        const failedDevices = deviceIds\n          .filter((deviceId) => !deviceOutcomes[deviceId].success)\n          .map((deviceId) => ({\n            deviceId,\n            reason: deviceOutcomes[deviceId].reasons.join(' | ') || 'Execution failed.',\n          }));\n        const successes = deviceIds.filter((deviceId) => deviceOutcomes[deviceId].success);\n        const timestamp = report.timestamp;\n\n        if (successes.length > 0) {\n          recordWorkflowRun(workflow.id, timestamp);\n          successes.forEach((deviceId) => recordDeviceWorkflowRun(deviceId, workflow.id, workflow.name, timestamp));\n        } else {\n          updateStoredWorkflow(workflow.id, { lastRunAt: timestamp });\n        }\n\n        successes.forEach((deviceId) =>\n          recordDeviceActivity({\n            deviceId,\n            type: 'workflow',\n            label: workflow.name,\n            status: 'success',\n            referenceId: workflow.id,\n            timestamp,\n          })\n        );\n        failedDevices.forEach(({ deviceId, reason }) =>\n          recordDeviceActivity({\n            deviceId,\n            type: 'workflow',\n            label: workflow.name,\n            status: 'failure',\n            referenceId: workflow.id,\n            details: reason,\n            timestamp,\n          })\n        );\n\n        if (failedDevices.length === 0) {\n          setSnackbar({\n            severity: 'success',\n            message: `${runLabel} of "${workflow.name}" completed on ${successes.length} device${successes.length === 1 ? '' : 's'}.`,\n          });\n        } else if (successes.length > 0) {\n          const failedList = failedDevices.map((failure) => failure.deviceId).join(', ');\n          setSnackbar({\n            severity: 'warning',\n            message: `${runLabel} of "${workflow.name}" completed with warnings. Failed for: ${failedList}.`,\n          });\n        } else {\n          const failureReasons = failedDevices.map((failure) => `${failure.deviceId}: ${failure.reason}`).join(' | ');\n          setSnackbar({\n            severity: 'error',\n            message: `${runLabel} of "${workflow.name}" failed on all devices. ${failureReasons}`,\n          });\n        }\n\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]:\n            failedDevices.length === 0\n              ? `${runLabel} completed successfully.`\n              : successes.length > 0\n                ? `${runLabel} completed with warnings.`\n                : `${runLabel} failed.`,\n        }));\n\n        completedRuns = runCounter;\n\n        const elapsedMs = Date.now() - sessionStart;\n        const needMoreByCount = runCounter < normalizedRepeatCount;\n        const needMoreByDuration = durationSeconds > 0 && elapsedMs < durationWindowMs;\n        if (!(needMoreByCount || needMoreByDuration)) {\n          break;\n        }\n\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `${runLabel} completed. Preparing next run.`,\n        }));\n        await sleep(1200);\n      }\n\n      if (cancelled) {\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `Workflow "${workflow.name}" cancelled after ${completedRuns} completed run${completedRuns === 1 ? '' : 's'}.`,\n        }));\n      } else {\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `Workflow "${workflow.name}" completed after ${completedRuns} run${completedRuns === 1 ? '' : 's'}.`,\n        }));\n      }\n    } catch (error) {\n      cancelled = cancelled || isWorkflowCancelled(workflow.id);\n      if (cancelled) {\n        setSnackbar({\n          severity: 'info',\n          message: `Workflow "${workflow.name}" cancelled after ${completedRuns} completed run${completedRuns === 1 ? '' : 's'}.`,\n        });\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `Workflow "${workflow.name}" cancelled after ${completedRuns} completed run${completedRuns === 1 ? '' : 's'}.`,\n        }));\n      } else {\n        const message = error instanceof Error ? error.message : 'Unknown error while communicating with the backend.';\n        setSnackbar({ severity: 'error', message: `Failed to run workflow "${workflow.name}": ${message}` });\n        setWorkflowRunStatus((prev) => ({\n          ...prev,\n          [workflow.id]: `Workflow "${workflow.name}" failed${runCounter > 0 ? ` during run #${runCounter}` : ''}: ${message}`;\n        }));\n      }\n      await sleep(1200);\n    } finally {\n      clearWorkflowCancellation(workflow.id);\n      setWorkflowPauseRequests((prev) => {\n        const next = { ...prev };\n        delete next[workflow.id];\n        return next;\n      });\n      setRunningWorkflows((prev) => {\n        const next = { ...prev };\n        delete next[workflow.id];\n        return next;\n      });\n      setWorkflowActiveModuleIndex((prev) => {\n        const next = { ...prev };\n        delete next[workflow.id];\n        return next;\n      });\n      setWorkflowCompletedModules((prev) => {\n        const next = { ...prev };\n        delete next[workflow.id];\n        return next;\n      });\n      setWorkflowRunStatus((prev) => {\n        const next = { ...prev };\n        delete next[workflow.id];\n        return next;\n      });\n    }\n  };\n"""
new_text = text[:start_idx] + new_block + text[end_idx:]
path.write_text(new_text, encoding='utf-8')
